#pragma once

#include <array>
#include <string>
#include <vector>

#include "Common.h"
#include "v2d.h"

namespace ElecSim {

  enum class TileType : int {
    Wire,
    Junction,
    Emitter,
    SemiConductor,
    Button,
    Inverter,
    Crossing
  };

  const std::string_view TileTypeToString(TileType type);

/**
 * @class GridTile
 * @brief Base class for all tile types in the simulation.
 * 
 * GridTile provides the common interface and functionality for all tiles,
 * including position management, signal processing, and serialization.
 */
class GridTile {
 protected:
  vi2d pos;
  Direction facing;
  bool activated;
  bool defaultActivation;
  TileSideStates canReceive;
  TileSideStates canOutput;
  TileSideStates inputStates;

 public:
  GridTile(vi2d pos = vi2d(0, 0), Direction facing = Direction::Top,
           bool defaultActivation = false);

  GridTile(const GridTile& other);
  GridTile(GridTile&& other) noexcept;
  GridTile& operator=(const GridTile& other);

  virtual ~GridTile() {};

  /**
   * @brief Initialize the tile (called once at startup).
   * @return Vector of initial signal events
   */
  virtual std::vector<SignalEvent> Init() { return {}; };
  
  /**
   * @brief Process an incoming signal and generate output signals.
   * @param signal The incoming signal to process
   * @return Vector of output signal events
   */
  virtual std::vector<SignalEvent> ProcessSignal(const SignalEvent& signal) = 0;
  
  /**
   * @brief Handle user interaction with the tile.
   * @return Vector of signal events generated by interaction
   */
  virtual std::vector<SignalEvent> Interact() { return {}; }
  
  /**
   * @brief Process signal without side effects (used for preprocessing).
   * @param incomingSignal The signal to preprocess
   * @return Vector of output signal events
   */
  virtual std::vector<SignalEvent> PreprocessSignal(
      const SignalEvent incomingSignal) = 0;

  void SetPos(vi2d newPos) { pos = newPos; }
  void SetActivation(bool newActivated) { activated = newActivated; }
  void SetFacing(Direction newFacing);
  void SetDefaultActivation(bool newDefault) { defaultActivation = newDefault; }
  void ToggleInputState(Direction dir) {
    if (canReceive[dir]) {
      inputStates[dir] = !inputStates[dir];
    }
  }
  virtual void
  ResetActivation();  // Changed from inline to virtual with implementation

  bool GetActivation() const { return activated; }
  bool GetDefaultActivation() const { return defaultActivation; }
  const vi2d GetPos() const { return pos; }
  const Direction& GetFacing() const { return facing; }
  std::string GetTileInformation() const;

  bool CanReceiveFrom(Direction dir) const { return canReceive[dir]; }
  bool CanOutputTo(Direction dir) const { return canOutput[dir]; }

  virtual bool IsEmitter() const = 0;
  virtual bool IsDeterministic() const = 0;
  virtual TileType GetTileType() const = 0;

  /**
   * @brief Create a deep copy of this tile.
   * @return Unique pointer to the cloned tile
   */
  [[nodiscard]] virtual std::unique_ptr<GridTile> Clone() const = 0;

  std::array<char, GRIDTILE_BYTESIZE> Serialize();
  static std::unique_ptr<GridTile> Deserialize(
      std::array<char, GRIDTILE_BYTESIZE> data);

 protected:
  /**
   * @brief Convert world direction to tile-relative direction.
   * @param worldDir Direction in world coordinates
   * @return Direction relative to tile's facing
   */
  Direction WorldToTileDirection(Direction worldDir) const;
  
  /**
   * @brief Convert tile-relative direction to world direction.
   * @param tileDir Direction relative to tile's facing
   * @return Direction in world coordinates
   */
  Direction TileToWorldDirection(Direction tileDir) const;
};

/**
 * @class DeterministicTile
 * @brief Base class for tiles with deterministic behavior.
 * 
 * Deterministic tiles always produce the same output for the same input,
 * making them suitable for preprocessing and optimization.
 */
class DeterministicTile : public GridTile {
 public:
  explicit DeterministicTile(vi2d newPos = vi2d(0, 0),
                             Direction newFacing = Direction::Top,
                             bool newDefaultActivation = false)
      : GridTile(newPos, newFacing, newDefaultActivation) {}

  bool IsDeterministic() const override { return true; }
  bool IsEmitter() const override { return false; }
};

/**
 * @class LogicTile
 * @brief Base class for tiles with non-deterministic or stateful behavior.
 * 
 * Logic tiles may have internal state or time-dependent behavior that
 * prevents preprocessing optimization.
 */
class LogicTile : public GridTile {
 public:
  explicit LogicTile(vi2d newPos = vi2d(0, 0),
                     Direction newFacing = Direction::Top,
                     bool newDefaultActivation = false)
      : GridTile(newPos, newFacing, newDefaultActivation) {}
  bool IsDeterministic() const override { return false; }
  std::vector<SignalEvent> PreprocessSignal(
      [[maybe_unused]] const SignalEvent incomingSignal) override {
    throw std::runtime_error(std::format(
        "Preprocessing is not supported for a Logic Tile of type {}",
        TileTypeToString(GetTileType())));
  }
};

}  // namespace ElecSim
